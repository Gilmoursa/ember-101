# Computed Properties and Observers

We already covered computed properties, which we use in different parts
of our applications. One of these uses occurs on the friend model:

{title="app/models/friend.js", lang="JavaScript"}
~~~~~~~~
import DS from 'ember-data';
import Ember from 'ember';

export default DS.Model.extend({
  // ...
  fullName: Ember.computed('firstName', 'lastName', function() {
    return this.get('firstName') + ' ' + this.get('lastName');
  })
});
~~~~~~~~

With the code above, we created a new property on the model called
**fullName** that depends on **firstName** and **lastName**. The
computed properties are called once at the beginning and the result is
cached until any of the dependent properties change.

Next we'll talk about a couple of features and things to keep
in mind when defining computed properties.

## Computed Property function signature

The functions we've used to declare a computed property have looked
like the following:

{title="Computed Property Function", lang="JavaScript"}
~~~~~~~~
fullName: Ember.computed('firstName', 'lastName', Ember.function() {
  return this.get('firstName') + ' ' + this.get('lastName');
})
~~~~~~~~

Using the previous signature in the **function** we passed to
`Ember.computed` we get computed properties working, but we can
optionally specify it like so:

{title="Computed Property Function", lang="JavaScript"}
~~~~~~~~
fullName: Ember.computed('firstName', 'lastName', function(key, value, oldValue) {
  return this.get('firstName') + ' ' + this.get('lastName');
}
~~~~~~~~

Now we can add support for setting the value of a computed
property and handling how it should behave. The following is an excerpt
from the Ember documentation where **firstName** and
**lastName** are used:

{title="Computed Property with set support", lang="JavaScript"}
~~~~~~~~
fullName: Ember.computed('firstName', 'lastName', function(key, value, oldValue) {
  if (arguments.length === 1) {
    //
    // Works as getter
    //

    return this.get('firstName') + ' ' + this.get('lastName')
  } else {

    //
    // Works as setter
    //

    var name = value.split(' ');

    this.set('firstName', name[0]);
    this.set('lastName', name[1]);

    return value;
  }
})
~~~~~~~~

I> For the curious, the following class has the implementation for [computed property](https://github.com/emberjs/ember.js/blob/v1.7.0/packages/ember-metal/lib/computed.js#L78).


Why didn't we mention that we can use a computed property as
setter? This is a very uncommon scenario that tends to
cause a lot of confusion for people. Ideally, we use computed
properties as Read-Only. In a later version of Ember, this might be the
default. [Stefan Penner](https://twitter.com/stefanpenner) created an issue that aims to make
computed properties Read-Only by default: [default readOnly
CP #9290](https://github.com/emberjs/ember.js/issues/9290).


## Computed Properties gotchas

Computed properties and observers are normally fired whenever we call
`this.set()` on the property they depend on. The downside of this is that they
will be recalculated even if the value is the same.

Fortunately for us, [Gavin Joyce](https://twitter.com/gavinjoyce)
wrote an **ember-cli-addon** called
[ember-computed-change-gate](https://github.com/GavinJoyce/ember-computed-change-gate)
that offers an alternative function to define computed properties
and that fixes observers such that they are only called if the property
they depend on has changed.

We can install the addon with `npm i ember-computed-change-gate
--save-dev` and use it in our friends model like so:

{title="Using ember-computed-change-gate in app/models/friend.js", lang="JavaScript"}
~~~~~~~~
import DS from 'ember-data';
import Ember from 'ember';
import changeGate from 'ember-computed-change-gate/change-gate';

export default DS.Model.extend({
  //
  // Currently changeGate only support one property
  //
  capitalizedFirstName: changeGate('firstName', function(firstName) {
    return Ember.String.capitalize(firstName);
  })
});
~~~~~~~~

Now our computed property `capitalizedFirstName` will be called
only when the value of the dependent key has changed to a
different value.

## Observers

Ember has a built-in implementation of the
[Observer pattern](http://en.wikipedia.org/wiki/Observer_pattern),
which allows us to keep track of changes in any property or
computed property.

We use observers to implement auto saving in the article-row component
with the following:

{title="app/components/articles/article-row.js", lang="JavaScript"}
~~~~~~~~
  stateChanged: Ember.on('init', Ember.observer('article.state', function() {
    var article = this.get('article');
    if (article.get('isDirty') && !article.get('isSaving')) {
      Ember.run.once(this, this.autoSave);
    }
  }))
~~~~~~~~

We define an observer calling `Ember.observer` which receives any
number of properties to observe and the function to call when any of
the properties change.

To enable the observer we pass it as an argument to `Ember.on('init,
args...)`. By default, observers are not switched on until the function
where they are defined is called. If we define the observer as
follows:

{title=""app/components/articles/article-row.js", lang="JavaScript"}
~~~~~~~~
  stateChanged: Ember.observer('article.state', function() {
    var article = this.get('article');
    if (article.get('isDirty') && !article.get('isSaving')) {
      Ember.run.once(this, this.autoSave);
    }
  })
~~~~~~~~

Then the observer won't have any effect until the function
`stateChanged` is called. To make sure the observer is enabled we use
`Ember.on('init', args)`, which calls the function as soon as the
object where the function is defined gets created. In our example,
that would be when an instance of `"app/components/articles/article-row.js` is created.

I> We might find some examples where observers are set calling
I> `.observer('property')` at the end of a function definition.
I> This pattern is valid but it relies on a mechanism called prototype
I> extensions which might get removed in future versions of Ember.
I> Please refer to the following pull request for more information
I> [emberjs/guides/pull/110](https://github.com/emberjs/guides/pull/110)


We can also create an observer using `addObserver` from
[Ember.Observable](http://emberjs.com/api/classes/Ember.Observable.html).
We could define the `stateChanged` observer like this:

{title=""app/components/articles/article-row.js", lang="JavaScript"}
~~~~~~~~
  setObserver: function() {
    this.addObserver(article.state', this, this.stateChanged);
    // we need to call get on the property so the observers are setup
    // see for more info http://cl.ly/1f0Y1v2A1G04

    this.get('article').get('state');
  }.on('init'),
  stateChanged: function() {
    if (this.get(article.isDirty') && !this.get(article.isSaving')) {
      Ember.run.once(this, this.autoSave);
    }
  }
~~~~~~~~

## Observing collections

Ember adds two convenient properties to collections. We can use
them if we want to observe changes to any of the members' properties,
or if we want to do something every time an element is
added or removed.

The first property is
[.[]](http://emberjs.com/api/classes/Ember.Array.html#property__),
which is just a special handler that changes every time the
collection content changes.

The second one is
[@each](http://emberjs.com/api/classes/Ember.Array.html#property__each),
which allows us to observe properties on each of the items in the
collection.

We can use the previous function in our articles index to call a
function when we add a new article, and then other one when we change
the state of an article:


{title="app/controllers/articles/index.js", lang="JavaScript"}
~~~~~~~~
import Ember from 'ember';

export default Ember.Controller.extend({
  contentDidChange: Ember.observer('model.[]', function() {
    console.log('Called when we add or removed an article.');
  }),
  stateDidChange: Ember.observer('model.@each.state', function() {
    console.log('Called when the state property change for any of the articles.');
  })
});
~~~~~~~~

If we visit any of our friends' profiles and change the state for any
article or add a new one, we'll see the relevant messages in the browser's
console.
